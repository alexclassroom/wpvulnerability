<?php
/**
 * CLI functions
 *
 * @package WPVulnerability
 *
 * @version 2.0.0
 */

defined( 'ABSPATH' ) || die( 'No script kiddies please!' );

/**
 * Registers a WP-CLI command for WPVulnerability plugin.
 *
 * @since 2.0.0
 *
 * @return void
 */
if ( defined( 'WP_CLI' ) && WP_CLI ) {

	/**
	 * Core section in WP-CLI command
	 *
	 * @since 2.0.0
	 *
	 * @return void
	 */
	function wpvulnerability_cli_core() {

		$core_vulnerabilities = array();
		if ( wpvulnerability_analyze_filter( 'core' ) ) {

			// Get core vulnerabilities.
			$core_vulnerabilities = wpvulnerability_core_get_vulnerabilities();

		}

		$vulnerabilities = array();

		if ( $core_vulnerabilities && is_array( $core_vulnerabilities ) ) {

			// Loop through each core vulnerability.
			foreach ( $core_vulnerabilities as $vulnerability ) {

				$severity = null;
				if ( isset( $vulnerability['impact']['cvss']['severity'] ) ) {
					$severity = wpvulnerability_severity( $vulnerability['impact']['cvss']['severity'] );
				}

				// Add the vulnerability details to the array.
				array_push(
					$vulnerabilities,
					array(
						'Version'                   => trim( html_entity_decode( wp_kses( (string) $vulnerability['name'], 'strip' ) ) ),
						'Vulnerability information' => '[*] WordPress ' . trim( html_entity_decode( wp_kses( (string) $vulnerability['name'], 'strip' ) ) ),
					)
				);

				$what = array();
				if ( isset( $vulnerability['impact']['cwe'] ) && count( $vulnerability['impact']['cwe'] ) ) {

					array_push(
						$vulnerabilities,
						array(
							'Version'                   => ' ',
							'Vulnerability information' => ' ',
						)
					);

					foreach ( $vulnerability['impact']['cwe'] as $vulnerability_cwe ) {

						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => trim( html_entity_decode( wp_kses( (string) $vulnerability_cwe['name'], 'strip' ) ) ),
							)
						);

						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => trim( html_entity_decode( wp_kses( (string) $vulnerability_cwe['description'], 'strip' ) ) ),
							)
						);

					}
				}

				$score = null;
				if ( isset( $vulnerability['impact']['cvss']['score'] ) ) {
					$score = number_format( (float) $vulnerability['impact']['cvss']['score'], 1, '.', '' );
				}
				$severity = null;
				if ( isset( $vulnerability['impact']['cvss']['severity'] ) ) {
					$severity = wpvulnerability_severity( $vulnerability['impact']['cvss']['severity'] );
				}

				if ( ! is_null( $score ) || ! is_null( $severity ) ) {

					array_push(
						$vulnerabilities,
						array(
							'Version'                   => ' ',
							'Vulnerability information' => ' ',
						)
					);

					if ( ! is_null( $score ) ) {
						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => __( 'Global score: ', 'wpvulnerability' ) . $score . ' / 10',
							)
						);
					}
					if ( ! is_null( $severity ) ) {
						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => __( 'Severity: ', 'wpvulnerability' ) . $severity,
							)
						);
					}
				}

				if ( isset( $vulnerability['source'] ) && count( $vulnerability['source'] ) ) {

					array_push(
						$vulnerabilities,
						array(
							'Version'                   => ' ',
							'Vulnerability information' => ' ',
						)
					);

					foreach ( $vulnerability['source'] as $vulnerability_source ) {

						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => '[+] ' . trim( html_entity_decode( wp_kses( (string) $vulnerability_source['name'], 'strip' ) ) ),
							)
						);
						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => '    ' . esc_url_raw( (string) $vulnerability_source['link'], 'strip' ),
							)
						);

					}
				}

				array_push(
					$vulnerabilities,
					array(
						'Version'                   => ' ',
						'Vulnerability information' => ' ',
					)
				);

			}
		}

		// Format and output the vulnerabilities in a table.
		WP_CLI\Utils\format_items(
			'table',
			$vulnerabilities,
			array( 'Version', 'Vulnerability information' )
		);
	}

	/**
	 * Plugin section in WP-CLI command
	 *
	 * @since 2.0.0
	 *
	 * @return void
	 */
	function wpvulnerability_cli_plugins( $args, $format ) {

		// Validate the format.
		switch ( $format ) {
			case 'table':
				$format = 'table';
				break;
			case 'json':
				$format = 'json';
				break;
			default:
				WP_CLI::error( "'$format' is not a valid format.\nAvailable formats: table, json" );
				break;
		}

		$plugin_vulnerabilities = array();
		if ( wpvulnerability_analyze_filter( 'plugins' ) ) {

			// Get plugin vulnerabilities.
			$plugin_vulnerabilities = wpvulnerability_plugin_get_vulnerabilities();

		}

		$plugins_complete = array();
		$vulnerabilities = array();

		// Loop through each plugin vulnerability.
		foreach ( $plugin_vulnerabilities as $plugin ) {

			if ( 1 === $plugin['vulnerable'] ) {

				$plugins_complete_temp                 = array();
				$plugins_complete_temp_vulnerabilities = array();

				// Process theme name and slug.
				$plugins_complete_temp['name'] = trim( html_entity_decode( wp_kses( (string) $plugin['Name'], 'strip' ) ) );
				$plugins_complete_temp['slug'] = trim( html_entity_decode( wp_kses( (string) $plugin['slug'], 'strip' ) ) );

				// Prepare the vulnerabilities array for table format output.
				foreach ( $plugin['vulnerabilities'] as $vulnerability ) {

					// Process vulnerability severity.
					$plugins_complete_temp_vulnerabilities['severity'] = null;
					if ( isset( $vulnerability['impact']['cvss']['severity'] ) ) {
						$plugins_complete_temp_vulnerabilities['severity'] = wpvulnerability_severity( $vulnerability['impact']['cvss']['severity'] );
					}

					// Process vulnerability details.
					$plugins_complete_temp_vulnerabilities['version'] = trim( html_entity_decode( wp_kses( (string) $vulnerability['versions'], 'strip' ) ) );
					$plugins_complete_temp_vulnerabilities['name']    = trim( html_entity_decode( wp_kses( (string) $vulnerability['name'], 'strip' ) ) );
					$plugins_complete_temp_vulnerabilities['closed']  = (int) $vulnerability['closed'];
					$plugins_complete_temp_vulnerabilities['unfixed'] = (int) $vulnerability['unfixed'];

					// Process CWE details.
					$plugins_complete_temp_vulnerabilities['cwe'] = array();
					if ( isset( $vulnerability['impact']['cwe'] ) && count( $vulnerability['impact']['cwe'] ) ) {
						foreach ( $vulnerability['impact']['cwe'] as $vulnerability_cwe ) {
							$plugins_complete_temp_vulnerabilities['cwe'][] = array(
								'name'        => trim( html_entity_decode( wp_kses( (string) $vulnerability_cwe['name'], 'strip' ) ) ),
								'description' => trim( html_entity_decode( wp_kses( (string) $vulnerability_cwe['description'], 'strip' ) ) ),
							);
						}
					}

					// Process CVSS score.
					$plugins_complete_temp_vulnerabilities['score'] = null;
					if ( isset( $vulnerability['impact']['cvss']['score'] ) ) {
						$plugins_complete_temp_vulnerabilities['score'] = number_format( (float) $vulnerability['impact']['cvss']['score'], 1, '.', '' );
					}
					$plugins_complete_temp_vulnerabilities['severity'] = null;
					if ( isset( $vulnerability['impact']['cvss']['severity'] ) ) {
						$plugins_complete_temp_vulnerabilities['severity'] = wpvulnerability_severity( $vulnerability['impact']['cvss']['severity'] );
					}

					// Process vulnerability sources.
					$plugins_complete_temp_vulnerabilities['source'] = array();
					if ( isset( $vulnerability['source'] ) && count( $vulnerability['source'] ) ) {
						foreach ( $vulnerability['source'] as $vulnerability_source ) {
							$plugins_complete_temp_vulnerabilities['source'][] = array(
								'name' => trim( html_entity_decode( wp_kses( (string) $vulnerability_source['name'], 'strip' ) ) ),
								'link' => esc_url_raw( (string) $vulnerability_source['link'], 'strip' ),
							);
						}
					}

					$plugins_complete_temp['vulnerabilities'][] = $plugins_complete_temp_vulnerabilities;
					unset( $plugins_complete_temp_vulnerabilities, $vulnerability );
				}

				$plugins_complete[] = $plugins_complete_temp;
				unset( $plugins_complete_temp );
			}
			unset( $plugin );
		}

		// Format output based on the selected format.
		if ( 'table' === $format ) {

			foreach ( $plugins_complete as $p_vuln ) {
				$v_name = $p_vuln['slug'];

				foreach ( $p_vuln['vulnerabilities'] as $p_vul ) {

					$v_version = $p_vul['version'];

					// Determine if vulnerability is fixed.
					switch ( $p_vul['unfixed'] ) {
						default:
						case 0:
							$v_fixed = 'yes';
							break;
						case 1:
							$v_fixed = 'no';
							break;
					}

					// Determine if theme is closed.
					switch ( $p_vul['closed'] ) {
						default:
						case 0:
							$v_closed = 'no';
							break;
						case 1:
							$v_closed = 'yes';
							break;
					}
					$v_score    = $p_vul['score'];
					$v_severity = $p_vul['severity'];

					// Compile CWE descriptions.
					$v_description_array = array();
					foreach ( $p_vul['cwe'] as $p_cwe ) {
						if ( isset( $p_cwe['name'] ) ) {
							$v_description_array[] = $p_cwe['name'];
						}
					}
					$v_description = trim( implode( ' + ', $v_description_array ) );

					// Add to vulnerabilities array for table output.
					array_push(
						$vulnerabilities,
						array(
							'name'        => $v_name,
							'version'     => $v_version,
							'fixed'       => $v_fixed,
							'closed'      => $v_closed,
							'score'       => $v_score,
							'severity'    => $v_severity,
							'description' => $v_description,
						)
					);
				}
			}

			// Format and output the vulnerabilities in a table.
			WP_CLI\Utils\format_items(
				'table',
				$vulnerabilities,
				array( 'name', 'version', 'fixed', 'closed', 'score', 'severity', 'description' )
			);

		} elseif ( 'json' === $format ) {
			// Format and output the vulnerabilities in a JSON.
			echo wp_json_encode( $plugins_complete );
		}
	}


	/**
	 * Theme section in WP-CLI command
	 *
	 * This function retrieves and displays theme vulnerabilities
	 * based on the specified format (table or JSON).
	 *
	 * @since 2.0.0
	 *
	 * @param array  $args   The arguments passed from the command line.
	 * @param string $format The format for the output.
	 *
	 * @return void
	 */
	function wpvulnerability_cli_themes( $args, $format ) {

		// Validate the format.
		switch ( $format ) {
			case 'table':
				$format = 'table';
				break;
			case 'json':
				$format = 'json';
				break;
			default:
				WP_CLI::error( "'$format' is not a valid format.\nAvailable formats: table, json" );
				break;
		}

		$theme_vulnerabilities = array();
		if ( wpvulnerability_analyze_filter( 'themes' ) ) {
			// Get theme vulnerabilities.
			$theme_vulnerabilities = wpvulnerability_theme_get_vulnerabilities();
		}

		$themes_complete = array();
		$vulnerabilities = array();

		// Loop through each theme vulnerability.
		foreach ( $theme_vulnerabilities as $theme ) {

			if ( 1 === $theme['wpvulnerability']['vulnerable'] ) {

				$themes_complete_temp                 = array();
				$themes_complete_temp_vulnerabilities = array();

				// Process theme name and slug.
				$themes_complete_temp['name'] = trim( html_entity_decode( wp_kses( (string) $theme['wpvulnerability']['name'], 'strip' ) ) );
				$themes_complete_temp['slug'] = trim( html_entity_decode( wp_kses( (string) $theme['wpvulnerability']['slug'], 'strip' ) ) );

				// Prepare the vulnerabilities array for table format output.
				foreach ( $theme['wpvulnerability']['vulnerabilities'] as $vulnerability ) {

					// Process vulnerability severity.
					$themes_complete_temp_vulnerabilities['severity'] = null;
					if ( isset( $vulnerability['impact']['cvss']['severity'] ) ) {
						$themes_complete_temp_vulnerabilities['severity'] = wpvulnerability_severity( $vulnerability['impact']['cvss']['severity'] );
					}

					// Process vulnerability details.
					$themes_complete_temp_vulnerabilities['version'] = trim( html_entity_decode( wp_kses( (string) $vulnerability['versions'], 'strip' ) ) );
					$themes_complete_temp_vulnerabilities['name']    = trim( html_entity_decode( wp_kses( (string) $vulnerability['name'], 'strip' ) ) );
					$themes_complete_temp_vulnerabilities['closed']  = (int) $vulnerability['closed'];
					$themes_complete_temp_vulnerabilities['unfixed'] = (int) $vulnerability['unfixed'];

					// Process CWE details.
					$themes_complete_temp_vulnerabilities['cwe'] = array();
					if ( isset( $vulnerability['impact']['cwe'] ) && count( $vulnerability['impact']['cwe'] ) ) {
						foreach ( $vulnerability['impact']['cwe'] as $vulnerability_cwe ) {
							$themes_complete_temp_vulnerabilities['cwe'][] = array(
								'name'        => trim( html_entity_decode( wp_kses( (string) $vulnerability_cwe['name'], 'strip' ) ) ),
								'description' => trim( html_entity_decode( wp_kses( (string) $vulnerability_cwe['description'], 'strip' ) ) ),
							);
						}
					}

					// Process CVSS score.
					$themes_complete_temp_vulnerabilities['score'] = null;
					if ( isset( $vulnerability['impact']['cvss']['score'] ) ) {
						$themes_complete_temp_vulnerabilities['score'] = number_format( (float) $vulnerability['impact']['cvss']['score'], 1, '.', '' );
					}
					$themes_complete_temp_vulnerabilities['severity'] = null;
					if ( isset( $vulnerability['impact']['cvss']['severity'] ) ) {
						$themes_complete_temp_vulnerabilities['severity'] = wpvulnerability_severity( $vulnerability['impact']['cvss']['severity'] );
					}

					// Process vulnerability sources.
					$themes_complete_temp_vulnerabilities['source'] = array();
					if ( isset( $vulnerability['source'] ) && count( $vulnerability['source'] ) ) {
						foreach ( $vulnerability['source'] as $vulnerability_source ) {
							$themes_complete_temp_vulnerabilities['source'][] = array(
								'name' => trim( html_entity_decode( wp_kses( (string) $vulnerability_source['name'], 'strip' ) ) ),
								'link' => esc_url_raw( (string) $vulnerability_source['link'], 'strip' ),
							);
						}
					}

					$themes_complete_temp['vulnerabilities'][] = $themes_complete_temp_vulnerabilities;
					unset( $themes_complete_temp_vulnerabilities, $vulnerability );
				}

				$themes_complete[] = $themes_complete_temp;
				unset( $themes_complete_temp );
			}
			unset( $theme );
		}

		// Format output based on the selected format.
		if ( 'table' === $format ) {

			foreach ( $themes_complete as $t_vuln ) {
				$v_name = $t_vuln['slug'];

				foreach ( $t_vuln['vulnerabilities'] as $t_vul ) {

					$v_version = $t_vul['version'];

					// Determine if vulnerability is fixed.
					switch ( $t_vul['unfixed'] ) {
						default:
						case 0:
							$v_fixed = 'yes';
							break;
						case 1:
							$v_fixed = 'no';
							break;
					}

					// Determine if theme is closed.
					switch ( $t_vul['closed'] ) {
						default:
						case 0:
							$v_closed = 'no';
							break;
						case 1:
							$v_closed = 'yes';
							break;
					}
					$v_score    = $t_vul['score'];
					$v_severity = $t_vul['severity'];

					// Compile CWE descriptions.
					$v_description_array = array();
					foreach ( $t_vul['cwe'] as $t_cwe ) {
						if ( isset( $t_cwe['name'] ) ) {
							$v_description_array[] = $t_cwe['name'];
						}
					}
					$v_description = trim( implode( ' + ', $v_description_array ) );

					// Add to vulnerabilities array for table output.
					array_push(
						$vulnerabilities,
						array(
							'name'        => $v_name,
							'version'     => $v_version,
							'fixed'       => $v_fixed,
							'closed'      => $v_closed,
							'score'       => $v_score,
							'severity'    => $v_severity,
							'description' => $v_description,
						)
					);
				}
			}

			// Format and output the vulnerabilities in a table.
			WP_CLI\Utils\format_items(
				'table',
				$vulnerabilities,
				array( 'name', 'version', 'fixed', 'closed', 'score', 'severity', 'description' )
			);

		} elseif ( 'json' === $format ) {
			// Format and output the vulnerabilities in a JSON.
			echo wp_json_encode( $themes_complete );
		}
	}

	/**
	 * PHP section in WP-CLI command
	 *
	 * @since 3.0.0
	 *
	 * @return void
	 */
	function wpvulnerability_cli_php() {

		$php_vulnerabilities = array();
		if ( wpvulnerability_analyze_filter( 'php' ) ) {

			// Get PHP vulnerabilities.
			$php_vulnerabilities = wpvulnerability_php_get_vulnerabilities();

		}

		if ( isset( $php_vulnerabilities['vulnerabilities'] ) ) {

			$name = wp_kses( wpvulnerability_sanitize_version_php( phpversion() ), 'strip' );

			// Output the PHP name with red color.
			WP_CLI::line( WP_CLI::colorize( "%r$name%n " ) );

			// Prepare the vulnerabilities array for table format output.
			$vulnerabilities = array();

			// Loop through each PHP vulnerability.
			foreach ( $php_vulnerabilities['vulnerabilities'] as $php ) {

				// Add the vulnerability details to the array.
				array_push(
					$vulnerabilities,
					array(
						'Version'                   => trim( html_entity_decode( wp_kses( (string) $php['versions'], 'strip' ) ) ),
						'Vulnerability information' => '[*] ' . trim( html_entity_decode( wp_kses( (string) $php['name'], 'strip' ) ) ),
					)
				);
				if ( (int) $php['unfixed'] ) {

					array_push(
						$vulnerabilities,
						array(
							'Version'                   => ' ',
							'Vulnerability information' => '*** ' . __( 'This vulnerability appears to be unpatched. Stay tuned for upcoming theme updates.', 'wpvulnerability' ) . ' ***',
						)
					);

				}

				if ( isset( $php['source'] ) && count( $php['source'] ) ) {

					array_push(
						$vulnerabilities,
						array(
							'Version'                   => ' ',
							'Vulnerability information' => ' ',
						)
					);

					foreach ( $php['source'] as $vulnerability_source ) {

						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => '[+] ' . trim( html_entity_decode( wp_kses( (string) $vulnerability_source['id'], 'strip' ) ) ),
							)
						);
						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => trim( html_entity_decode( wp_kses( (string) $vulnerability_source['description'], 'strip' ) ) ),
							)
						);
						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => ' ' . esc_url_raw( (string) $vulnerability_source['link'], 'strip' ),
							)
						);

					}

					array_push(
						$vulnerabilities,
						array(
							'Version'                   => ' ',
							'Vulnerability information' => ' ',
						)
					);

				}
			}

			// Format and output the vulnerabilities in a table.
			WP_CLI\Utils\format_items(
				'table',
				$vulnerabilities,
				array( 'Version', 'Vulnerability information' )
			);

		}
	}

	/**
	 * Apache HTTPD section in WP-CLI command
	 *
	 * @since 3.2.0
	 *
	 * @return void
	 */
	function wpvulnerability_cli_apache() {

		$apache_vulnerabilities = array();
		if ( wpvulnerability_analyze_filter( 'apache' ) ) {

			// Get Apache HTTPD vulnerabilities.
			$apache_vulnerabilities = wpvulnerability_apache_get_vulnerabilities();

		}

		if ( isset( $apache_vulnerabilities['vulnerabilities'] ) ) {

			$webserver = wpvulnerability_detect_webserver();
			if ( isset( $webserver['id'] ) && 'apache' === $webserver['id'] && isset( $webserver['version'] ) && $webserver['version'] ) {
				// Get the Apache HTTPD version.
				$apache_version = wp_kses( (string) $webserver['version'], 'strip' );
				$name           = wp_kses( wpvulnerability_sanitize_version_apache( (string) $apache_version ), 'strip' );

				// Output the PHP name with red color.
				WP_CLI::line( WP_CLI::colorize( "%r$name%n " ) );

				// Prepare the vulnerabilities array for table format output.
				$vulnerabilities = array();

				// Loop through each PHP vulnerability.
				foreach ( $apache_vulnerabilities['vulnerabilities'] as $apache ) {

					// Add the vulnerability details to the array.
					array_push(
						$vulnerabilities,
						array(
							'Version'                   => trim( html_entity_decode( wp_kses( (string) $apache['versions'], 'strip' ) ) ),
							'Vulnerability information' => '[*] ' . trim( html_entity_decode( wp_kses( (string) $apache['name'], 'strip' ) ) ),
						)
					);
					if ( (int) $apache['unfixed'] ) {

						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => '*** ' . __( 'This vulnerability appears to be unpatched. Stay tuned for upcoming theme updates.', 'wpvulnerability' ) . ' ***',
							)
						);

					}

					if ( isset( $apache['source'] ) && count( $apache['source'] ) ) {

						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => ' ',
							)
						);

						foreach ( $apache['source'] as $vulnerability_source ) {

							array_push(
								$vulnerabilities,
								array(
									'Version' => ' ',
									'Vulnerability information' => '[+] ' . trim( html_entity_decode( wp_kses( (string) $vulnerability_source['id'], 'strip' ) ) ),
								)
							);
							array_push(
								$vulnerabilities,
								array(
									'Version' => ' ',
									'Vulnerability information' => trim( html_entity_decode( wp_kses( (string) $vulnerability_source['description'], 'strip' ) ) ),
								)
							);
							array_push(
								$vulnerabilities,
								array(
									'Version' => ' ',
									'Vulnerability information' => ' ' . esc_url_raw( (string) $vulnerability_source['link'], 'strip' ),
								)
							);

						}

						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => ' ',
							)
						);

					}
				}
			}

			// Format and output the vulnerabilities in a table.
			WP_CLI\Utils\format_items(
				'table',
				$vulnerabilities,
				array( 'Version', 'Vulnerability information' )
			);

		}
	}

	/**
	 * Nginx section in WP-CLI command
	 *
	 * @since 3.2.0
	 *
	 * @return void
	 */
	function wpvulnerability_cli_nginx() {

		$nginx_vulnerabilities = array();
		if ( wpvulnerability_analyze_filter( 'nginx' ) ) {

			// Get nginx vulnerabilities.
			$nginx_vulnerabilities = wpvulnerability_nginx_get_vulnerabilities();

		}

		if ( isset( $nginx_vulnerabilities['vulnerabilities'] ) ) {

			$webserver = wpvulnerability_detect_webserver();
			if ( isset( $webserver['id'] ) && 'nginx' === $webserver['id'] && isset( $webserver['version'] ) && $webserver['version'] ) {
				// Get the nginx version.
				$nginx_version = wp_kses( (string) $webserver['version'], 'strip' );
				$name          = wp_kses( wpvulnerability_sanitize_version_nginx( (string) $nginx_version ), 'strip' );

				// Output the PHP name with red color.
				WP_CLI::line( WP_CLI::colorize( "%r$name%n " ) );

				// Prepare the vulnerabilities array for table format output.
				$vulnerabilities = array();

				// Loop through each PHP vulnerability.
				foreach ( $nginx_vulnerabilities['vulnerabilities'] as $nginx ) {

					// Add the vulnerability details to the array.
					array_push(
						$vulnerabilities,
						array(
							'Version'                   => trim( html_entity_decode( wp_kses( (string) $nginx['versions'], 'strip' ) ) ),
							'Vulnerability information' => '[*] ' . trim( html_entity_decode( wp_kses( (string) $nginx['name'], 'strip' ) ) ),
						)
					);
					if ( (int) $nginx['unfixed'] ) {

						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => '*** ' . __( 'This vulnerability appears to be unpatched. Stay tuned for upcoming theme updates.', 'wpvulnerability' ) . ' ***',
							)
						);

					}

					if ( isset( $nginx['source'] ) && count( $nginx['source'] ) ) {

						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => ' ',
							)
						);

						foreach ( $nginx['source'] as $vulnerability_source ) {

							array_push(
								$vulnerabilities,
								array(
									'Version' => ' ',
									'Vulnerability information' => '[+] ' . trim( html_entity_decode( wp_kses( (string) $vulnerability_source['id'], 'strip' ) ) ),
								)
							);
							array_push(
								$vulnerabilities,
								array(
									'Version' => ' ',
									'Vulnerability information' => trim( html_entity_decode( wp_kses( (string) $vulnerability_source['description'], 'strip' ) ) ),
								)
							);
							array_push(
								$vulnerabilities,
								array(
									'Version' => ' ',
									'Vulnerability information' => ' ' . esc_url_raw( (string) $vulnerability_source['link'], 'strip' ),
								)
							);

						}

						array_push(
							$vulnerabilities,
							array(
								'Version' => ' ',
								'Vulnerability information' => ' ',
							)
						);

					}
				}
			}

			// Format and output the vulnerabilities in a table.
			WP_CLI\Utils\format_items(
				'table',
				$vulnerabilities,
				array( 'Version', 'Vulnerability information' )
			);

		}
	}

	/**
	 * Switches the command to show the list of vulnerabilities detected in the site.
	 *
	 * This function acts as a dispatcher that selects and executes the appropriate
	 * function based on the provided subcommand. It supports different output formats
	 * such as table and JSON.
	 *
	 * @since 2.0.0
	 *
	 * @param array $args      The subcommand to execute.
	 *                         Accepted values: 'core', 'plugins', 'themes', 'php', 'apache', 'nginx'.
	 * @param array $assoc_args Associative arguments passed from the command line.
	 *                          'format' (optional) - The format for the output. Defaults to 'table'.
	 *                          Accepted values: 'table', 'json'.
	 *
	 * @return void
	 */
	function wpvulnerability_cli_command( $args, $assoc_args ) {

		$subcommand = $args[0];
		$format     = isset( $assoc_args['format'] ) ? $assoc_args['format'] : 'table';

		// Selects the correct function to execute based on the subcommand.
		switch ( $subcommand ) {
			case 'core':
				wpvulnerability_cli_core( $args, $format );
				break;
			case 'plugins':
				wpvulnerability_cli_plugins( $args, $format );
				break;
			case 'themes':
				wpvulnerability_cli_themes( $args, $format );
				break;
			case 'php':
				wpvulnerability_cli_php( $args, $format );
				break;
			case 'apache':
				wpvulnerability_cli_apache( $args, $format );
				break;
			case 'nginx':
				wpvulnerability_cli_nginx( $args, $format );
				break;
			default:
				// Displays an error message for an invalid subcommand.
				WP_CLI::error( "'$subcommand' is not a registered subcommand of 'wpvulnerability'.\nAvailable subcommands: core, plugins, themes, php, apache, nginx" );
				break;
		}
	}

	/**
	 * Adds a WP-CLI command to show the list of vulnerabilities detected in your site.
	 *
	 * EXAMPLES
	 *
	 *  - wp wpvulnerability core
	 *  - wp wpvulnerability plugins
	 *  - wp wpvulnerability themes
	 *
	 * @param object $args Arguments passed from the command line.
	 *
	 * @return void
	 */
	WP_CLI::add_command(
		'wpvulnerability',
		'wpvulnerability_cli_command',
		array(
			'shortdesc' => 'Show the list of vulnerabilities detected in your site.',
			'synopsis'  => array(
				array(
					'type'        => 'positional',
					'name'        => 'subcommand',
					'description' => 'subcommand [core|plugins|themes|php|apache|nginx].',
					'optional'    => false,
				),
				array(
					'type'        => 'assoc',
					'name'        => 'format',
					'description' => 'Format for the output [table|json].',
					'optional'    => true,
					'default'     => 'table',
				),
			),
			'when'      => 'after_wp_load',
			'longdesc'  => "EXAMPLES:\n\n - wp wpvulnerability core\n - wp wpvulnerability plugins\n - wp wpvulnerability themes\n - wp wpvulnerability php\n - wp wpvulnerability apache\n - wp wpvulnerability nginx",
		)
	);

}
