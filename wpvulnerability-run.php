<?php
/**
 * Running functions
 *
 * @package WPVulnerability
 *
 * @version 2.0.0
 */

defined( 'ABSPATH' ) || die( 'No script kiddies please!' );

/**
 * Conditionally adds a settings link to the plugin row in the plugins list for a multisite network or single site installation.
 *
 * In a multisite environment, it adds a network admin settings link that appears in the network admin plugin row.
 * For a single site installation, it adds a standard settings link that appears in the plugin row.
 *
 * @since 3.0.0
 *
 * @param array $links The links that appear in the plugin row.
 *
 * @return array The modified array of links.
 */
if ( is_multisite() && is_network_admin() ) {

	/**
	 * Adds a network admin settings link to the plugin row in the network admin plugins list.
	 *
	 * @since 3.0.0
	 *
	 * @param array $links The links that appear in the network admin plugin row.
	 *
	 * @return array The modified array of links.
	 */
	function wpvulnerability_add_network_settings_link( $links ) {
		// Check if the user has the required capabilities to view the settings link.
		if ( wpvulnerability_capabilities() ) {
			// Add the network settings link to the plugin row.
			$links[] = '<a href="' . network_admin_url( 'settings.php?page=wpvulnerability-options' ) . '">' . __( 'Network Settings', 'wpvulnerability' ) . '</a>';
		}
		return $links;
	}
	add_filter( 'network_admin_plugin_action_links_' . WPVULNERABILITY_PLUGIN_BASE, 'wpvulnerability_add_network_settings_link' );

} elseif ( ! is_multisite() && is_admin() ) {

	/**
	 * Adds a standard settings link to the plugin row in the plugins list for a single site installation.
	 *
	 * @since 2.0.0
	 *
	 * @param array $links The links that appear in the plugin row.
	 *
	 * @return array The modified array of links.
	 */
	function wpvulnerability_add_settings_link( $links ) {
		// Check if the user has the required capabilities to view the settings link.
		if ( wpvulnerability_capabilities() ) {
			// Add the settings link to the plugin row.
			$links[] = '<a href="' . get_admin_url( null, 'options-general.php?page=wpvulnerability-options' ) . '">' . __( 'Settings', 'wpvulnerability' ) . '</a>';
		}
		return $links;
	}
	add_filter( 'plugin_action_links_' . WPVULNERABILITY_PLUGIN_BASE, 'wpvulnerability_add_settings_link' );
}

/**
 * Updates the plugin's data.
 *
 * This function updates the vulnerability data for core, plugins, themes, PHP, Apache, and nginx.
 * It ensures that the required functions are available by including the necessary files.
 * After updating the vulnerabilities, it flushes the WordPress cache.
 *
 * @since 2.0.0
 *
 * @return void
 */
function wpvulnerability_update_database_data() {

	// Ensure the core vulnerabilities function is available.
	if ( ! function_exists( 'wpvulnerability_core_get_vulnerabilities_clean' ) ) {
		require_once WPVULNERABILITY_PLUGIN_PATH . '/wpvulnerability-core.php';
	}
	// Update core vulnerabilities.
	wpvulnerability_core_get_vulnerabilities_clean();

	// Ensure the plugin vulnerabilities function is available.
	if ( ! function_exists( 'wpvulnerability_plugin_get_vulnerabilities_clean' ) ) {
		require_once WPVULNERABILITY_PLUGIN_PATH . '/wpvulnerability-plugins.php';
	}
	// Update plugin vulnerabilities.
	wpvulnerability_plugin_get_vulnerabilities_clean();

	// Ensure the theme vulnerabilities function is available.
	if ( ! function_exists( 'wpvulnerability_theme_get_vulnerabilities_clean' ) ) {
		require_once WPVULNERABILITY_PLUGIN_PATH . '/wpvulnerability-themes.php';
	}
	// Update theme vulnerabilities.
	wpvulnerability_theme_get_vulnerabilities_clean();

	// Ensure the PHP vulnerabilities function is available.
	if ( ! function_exists( 'wpvulnerability_php_get_vulnerabilities_clean' ) ) {
		require_once WPVULNERABILITY_PLUGIN_PATH . '/wpvulnerability-php.php';
	}
	// Update PHP vulnerabilities.
	wpvulnerability_php_get_vulnerabilities_clean();

	// Ensure the Apache vulnerabilities function is available.
	if ( ! function_exists( 'wpvulnerability_apache_get_vulnerabilities_clean' ) ) {
		require_once WPVULNERABILITY_PLUGIN_PATH . '/wpvulnerability-apache.php';
	}
	// Update Apache vulnerabilities.
	wpvulnerability_apache_get_vulnerabilities_clean();

	// Ensure the nginx vulnerabilities function is available.
	if ( ! function_exists( 'wpvulnerability_nginx_get_vulnerabilities_clean' ) ) {
		require_once WPVULNERABILITY_PLUGIN_PATH . '/wpvulnerability-nginx.php';
	}
	// Update nginx vulnerabilities.
	wpvulnerability_nginx_get_vulnerabilities_clean();

	// Clean the WordPress cache.
	wp_cache_flush();
}

/**
 * Updates the plugin's data when expired.
 *
 * This function checks if the cached vulnerability data has expired and updates it accordingly.
 * It ensures that the required functions are available by including the necessary files.
 * The function handles both multisite and single site installations.
 *
 * @since 3.0.0
 *
 * @return void
 */
function wpvulnerability_expired_database_data() {

	// Ensure the core vulnerabilities function is available.
	if ( ! function_exists( 'wpvulnerability_core_get_vulnerabilities_clean' ) ) {
		require_once WPVULNERABILITY_PLUGIN_PATH . '/wpvulnerability-core.php';
	}
	// Ensure the plugin vulnerabilities function is available.
	if ( ! function_exists( 'wpvulnerability_plugin_get_vulnerabilities_clean' ) ) {
		require_once WPVULNERABILITY_PLUGIN_PATH . '/wpvulnerability-plugins.php';
	}
	// Ensure the theme vulnerabilities function is available.
	if ( ! function_exists( 'wpvulnerability_theme_get_vulnerabilities_clean' ) ) {
		require_once WPVULNERABILITY_PLUGIN_PATH . '/wpvulnerability-themes.php';
	}
	// Ensure the PHP vulnerabilities function is available.
	if ( ! function_exists( 'wpvulnerability_php_get_vulnerabilities_clean' ) ) {
		require_once WPVULNERABILITY_PLUGIN_PATH . '/wpvulnerability-php.php';
	}
	// Ensure the Apache vulnerabilities function is available.
	if ( ! function_exists( 'wpvulnerability_apache_get_vulnerabilities_clean' ) ) {
		require_once WPVULNERABILITY_PLUGIN_PATH . '/wpvulnerability-apache.php';
	}
	// Ensure the nginx vulnerabilities function is available.
	if ( ! function_exists( 'wpvulnerability_nginx_get_vulnerabilities_clean' ) ) {
		require_once WPVULNERABILITY_PLUGIN_PATH . '/wpvulnerability-nginx.php';
	}

	// Current time for cache expiration comparison.
	$cache_time = time();

	if ( is_multisite() ) {
		// Check and update core vulnerabilities if cache has expired.
		if ( json_decode( get_site_option( 'wpvulnerability-core-cache' ) ) < $cache_time ) {
			wpvulnerability_core_get_vulnerabilities_clean();
		}
		// Check and update plugin vulnerabilities if cache has expired.
		if ( json_decode( get_site_option( 'wpvulnerability-plugins-cache' ) ) < $cache_time ) {
			wpvulnerability_plugin_get_vulnerabilities_clean();
		}
		// Check and update theme vulnerabilities if cache has expired.
		if ( json_decode( get_site_option( 'wpvulnerability-themes-cache' ) ) < $cache_time ) {
			wpvulnerability_theme_get_vulnerabilities_clean();
		}
		// Check and update PHP vulnerabilities if cache has expired.
		if ( json_decode( get_site_option( 'wpvulnerability-php-cache' ) ) < $cache_time ) {
			wpvulnerability_php_get_vulnerabilities_clean();
		}
		// Check and update Apache vulnerabilities if cache has expired.
		if ( json_decode( get_site_option( 'wpvulnerability-apache-cache' ) ) < $cache_time ) {
			wpvulnerability_apache_get_vulnerabilities_clean();
		}
		// Check and update nginx vulnerabilities if cache has expired.
		if ( json_decode( get_site_option( 'wpvulnerability-nginx-cache' ) ) < $cache_time ) {
			wpvulnerability_nginx_get_vulnerabilities_clean();
		}
	} elseif ( ! is_multisite() ) {
		// Check and update core vulnerabilities if cache has expired.
		if ( json_decode( get_option( 'wpvulnerability-core-cache' ) ) < $cache_time ) {
			wpvulnerability_core_get_vulnerabilities_clean();
		}
		// Check and update plugin vulnerabilities if cache has expired.
		if ( json_decode( get_option( 'wpvulnerability-plugins-cache' ) ) < $cache_time ) {
			wpvulnerability_plugin_get_vulnerabilities_clean();
		}
		// Check and update theme vulnerabilities if cache has expired.
		if ( json_decode( get_option( 'wpvulnerability-themes-cache' ) ) < $cache_time ) {
			wpvulnerability_theme_get_vulnerabilities_clean();
		}
		// Check and update PHP vulnerabilities if cache has expired.
		if ( json_decode( get_option( 'wpvulnerability-php-cache' ) ) < $cache_time ) {
			wpvulnerability_php_get_vulnerabilities_clean();
		}
		// Check and update Apache vulnerabilities if cache has expired.
		if ( json_decode( get_option( 'wpvulnerability-apache-cache' ) ) < $cache_time ) {
			wpvulnerability_apache_get_vulnerabilities_clean();
		}
		// Check and update nginx vulnerabilities if cache has expired.
		if ( json_decode( get_option( 'wpvulnerability-nginx-cache' ) ) < $cache_time ) {
			wpvulnerability_nginx_get_vulnerabilities_clean();
		}
	}

	unset( $cache_time );
}

/**
 * Callback function for when the plugin is activated.
 * Adds plugin data options if they are not already created.
 *
 * @since 2.0.0
 *
 * @return void
 */
function wpvulnerability_activation() {

	if ( is_multisite() ) {

		// Add wpvulnerability-config option if it does not exist.
		if ( ! get_site_option( 'wpvulnerability-config' ) ) {
			$config = get_option( 'wpvulnerability-config' );

			// Check if emails and period are set in the existing config.
			if ( isset( $config['emails'] ) && $config['emails'] && isset( $config['period'] ) && $config['period'] ) {
				add_site_option(
					'wpvulnerability-config',
					array(
						'emails' => $config['emails'],
						'period' => $config['period'],
					)
				);
				unset( $config );
			} else {
				add_site_option(
					'wpvulnerability-config',
					array(
						'emails' => get_bloginfo( 'admin_email' ),
						'period' => 'weekly',
					)
				);
			}
		}

		// Add other site options if they do not exist.
		$options = array(
			'wpvulnerability-plugins'            => '',
			'wpvulnerability-plugins-cache'      => 0,
			'wpvulnerability-plugins-vulnerable' => 0,
			'wpvulnerability-plugins-data'       => '',
			'wpvulnerability-plugins-data-cache' => 0,
			'wpvulnerability-themes'             => '',
			'wpvulnerability-themes-cache'       => 0,
			'wpvulnerability-themes-vulnerable'  => 0,
			'wpvulnerability-core'               => '',
			'wpvulnerability-core-cache'         => 0,
			'wpvulnerability-core-vulnerable'    => 0,
			'wpvulnerability-php'                => '',
			'wpvulnerability-php-cache'          => 0,
			'wpvulnerability-php-vulnerable'     => 0,
			'wpvulnerability-apache'             => '',
			'wpvulnerability-apache-cache'       => 0,
			'wpvulnerability-apache-vulnerable'  => 0,
			'wpvulnerability-nginx'              => '',
			'wpvulnerability-nginx-cache'        => 0,
			'wpvulnerability-nginx-vulnerable'   => 0,
		);

		foreach ( $options as $key => $value ) {
			if ( ! get_site_option( $key ) ) {
				add_site_option( $key, $value );
			}
		}

		// Add wpvulnerability-analyze option if it does not exist.
		if ( ! get_site_option( 'wpvulnerability-analyze' ) ) {
			$analyze = get_option( 'wpvulnerability-analyze' );

			if ( isset( $analyze['core'] ) && isset( $analyze['plugins'] ) && isset( $analyze['themes'] ) && isset( $analyze['php'] ) && isset( $analyze['apache'] ) && isset( $analyze['nginx'] ) ) {
				add_site_option(
					'wpvulnerability-analyze',
					array(
						'core'    => $analyze['core'],
						'plugins' => $analyze['plugins'],
						'themes'  => $analyze['themes'],
						'php'     => $analyze['php'],
						'apache'  => $analyze['apache'],
						'nginx'   => $analyze['nginx'],
					)
				);
				unset( $analyze );
			} else {
				add_site_option(
					'wpvulnerability-analyze',
					array(
						'core'    => 0,
						'plugins' => 0,
						'themes'  => 0,
						'php'     => 0,
						'apache'  => 0,
						'nginx'   => 0,
					)
				);
			}
		}
	} elseif ( ! is_multisite() ) {

		// Add wpvulnerability-config option if it does not exist.
		if ( ! get_option( 'wpvulnerability-config' ) ) {
			add_option(
				'wpvulnerability-config',
				array(
					'emails' => get_bloginfo( 'admin_email' ),
					'period' => 'weekly',
				)
			);
		}

		// Add other options if they do not exist.
		$options = array(
			'wpvulnerability-plugins'            => '',
			'wpvulnerability-plugins-cache'      => 0,
			'wpvulnerability-plugins-vulnerable' => 0,
			'wpvulnerability-plugins-data'       => '',
			'wpvulnerability-plugins-data-cache' => 0,
			'wpvulnerability-themes'             => '',
			'wpvulnerability-themes-cache'       => 0,
			'wpvulnerability-themes-vulnerable'  => 0,
			'wpvulnerability-core'               => '',
			'wpvulnerability-core-cache'         => 0,
			'wpvulnerability-core-vulnerable'    => 0,
			'wpvulnerability-php'                => '',
			'wpvulnerability-php-cache'          => 0,
			'wpvulnerability-php-vulnerable'     => 0,
			'wpvulnerability-apache'             => '',
			'wpvulnerability-apache-cache'       => 0,
			'wpvulnerability-apache-vulnerable'  => 0,
			'wpvulnerability-nginx'              => '',
			'wpvulnerability-nginx-cache'        => 0,
			'wpvulnerability-nginx-vulnerable'   => 0,
		);

		foreach ( $options as $key => $value ) {
			if ( ! get_option( $key ) ) {
				add_option( $key, $value );
			}
		}

		// Add wpvulnerability-config option if it does not exist.
		if ( ! get_option( 'wpvulnerability-analyze' ) ) {
			add_option(
				'wpvulnerability-analyze',
				array(
					'core'    => 0,
					'plugins' => 0,
					'themes'  => 0,
					'php'     => 0,
					'apache'  => 0,
					'nginx'   => 0,
				)
			);
		}
	}
}

/**
 * On Deactivation
 * Callback function to run when the plugin is deactivated.
 * Deletes options and removes scheduled wp-cron jobs.
 *
 * @since 2.0.0
 *
 * @return void
 */
function wpvulnerability_deactivation() {

	if ( is_multisite() ) {

		// Delete all plugin options for multisite.
		$multisite_options = array(
			'wpvulnerability_settings',
			'wpvulnerability-data',
			'wpvulnerability-analyze',
			'wpvulnerability-themes',
			'wpvulnerability-themes-cache',
			'wpvulnerability-themes-vulnerable',
			'wpvulnerability-plugins',
			'wpvulnerability-plugins-cache',
			'wpvulnerability-plugins-vulnerable',
			'wpvulnerability-core',
			'wpvulnerability-core-cache',
			'wpvulnerability-core-vulnerable',
			'wpvulnerability-php',
			'wpvulnerability-php-cache',
			'wpvulnerability-php-vulnerable',
			'wpvulnerability-apache',
			'wpvulnerability-apache-cache',
			'wpvulnerability-apache-vulnerable',
			'wpvulnerability-nginx',
			'wpvulnerability-nginx-cache',
			'wpvulnerability-nginx-vulnerable',
		);

		foreach ( $multisite_options as $option ) {
			delete_site_option( $option );
		}
	} else {

		// Delete all plugin options for single site.
		$single_site_options = array(
			'wpvulnerability_settings',
			'wpvulnerability-data',
			'wpvulnerability-analyze',
			'wpvulnerability-themes',
			'wpvulnerability-themes-cache',
			'wpvulnerability-themes-vulnerable',
			'wpvulnerability-plugins',
			'wpvulnerability-plugins-cache',
			'wpvulnerability-plugins-vulnerable',
			'wpvulnerability-core',
			'wpvulnerability-core-cache',
			'wpvulnerability-core-vulnerable',
			'wpvulnerability-php',
			'wpvulnerability-php-cache',
			'wpvulnerability-php-vulnerable',
			'wpvulnerability-apache',
			'wpvulnerability-apache-cache',
			'wpvulnerability-apache-vulnerable',
			'wpvulnerability-nginx',
			'wpvulnerability-nginx-cache',
			'wpvulnerability-nginx-vulnerable',
		);

		foreach ( $single_site_options as $option ) {
			delete_option( $option );
		}
	}

	// Unschedule and remove scheduled wp-cron jobs.
	wp_unschedule_event( wp_next_scheduled( 'wpvulnerability_notification' ), 'wpvulnerability_notification' );
	wp_clear_scheduled_hook( 'wpvulnerability_notification' );

	wp_unschedule_event( wp_next_scheduled( 'wpvulnerability_update_database' ), 'wpvulnerability_update_database' );
	wp_clear_scheduled_hook( 'wpvulnerability_update_database' );

	wp_unschedule_event( wp_next_scheduled( 'wpvulnerability_pull_db_data_event' ), 'wpvulnerability_pull_db_data_event' );
	wp_clear_scheduled_hook( 'wpvulnerability_pull_db_data_event' );
}

/**
 * On Uninstall
 * Callback function to run when the plugin is uninstalled.
 * Deletes options and removes scheduled wp-cron jobs.
 *
 * @since 3.0.0
 *
 * @return void
 */
function wpvulnerability_uninstall() {

	// Deprecated options.
	delete_option( 'wpvulnerability_settings' );
	delete_option( 'wpvulnerability-data' );

	// Delete all plugin data options.
	$options = array(
		'wpvulnerability-themes',
		'wpvulnerability-themes-cache',
		'wpvulnerability-themes-vulnerable',
		'wpvulnerability-plugins',
		'wpvulnerability-plugins-cache',
		'wpvulnerability-plugins-vulnerable',
		'wpvulnerability-core',
		'wpvulnerability-core-cache',
		'wpvulnerability-core-vulnerable',
		'wpvulnerability-php',
		'wpvulnerability-php-cache',
		'wpvulnerability-php-vulnerable',
		'wpvulnerability-apache',
		'wpvulnerability-apache-cache',
		'wpvulnerability-apache-vulnerable',
		'wpvulnerability-nginx',
		'wpvulnerability-nginx-cache',
		'wpvulnerability-nginx-vulnerable',
		'wpvulnerability-analyze',
	);

	foreach ( $options as $option ) {
		delete_option( $option );
	}

	// Config data, not deleted when deactivated.
	delete_option( 'wpvulnerability-config' );

	// Delete all multisite options.
	$multisite_options = array(
		'wpvulnerability-themes',
		'wpvulnerability-themes-cache',
		'wpvulnerability-themes-vulnerable',
		'wpvulnerability-plugins',
		'wpvulnerability-plugins-cache',
		'wpvulnerability-plugins-vulnerable',
		'wpvulnerability-core',
		'wpvulnerability-core-cache',
		'wpvulnerability-core-vulnerable',
		'wpvulnerability-php',
		'wpvulnerability-php-cache',
		'wpvulnerability-php-vulnerable',
		'wpvulnerability-apache',
		'wpvulnerability-apache-cache',
		'wpvulnerability-apache-vulnerable',
		'wpvulnerability-nginx',
		'wpvulnerability-nginx-cache',
		'wpvulnerability-nginx-vulnerable',
		'wpvulnerability-analyze',
	);

	foreach ( $multisite_options as $option ) {
		delete_site_option( $option );
	}

	// Config data (Multisite), not deleted when deactivated.
	delete_site_option( 'wpvulnerability-config' );

	// Unschedule and remove scheduled wp-cron jobs.
	wp_unschedule_event( wp_next_scheduled( 'wpvulnerability_notification' ), 'wpvulnerability_notification' );
	wp_clear_scheduled_hook( 'wpvulnerability_notification' );

	wp_unschedule_event( wp_next_scheduled( 'wpvulnerability_update_database' ), 'wpvulnerability_update_database' );
	wp_clear_scheduled_hook( 'wpvulnerability_update_database' );
}

/**
 * Filters and returns the WPVulnerability analysis setting for a given type.
 *
 * This function retrieves the WPVulnerability analysis settings, either from
 * the single site or the multisite network, depending on the WordPress setup.
 * It then returns false if the specified type ('core', 'plugins', 'themes',
 * 'php', 'apache', 'nginx') is set. If the type is not set or is invalid, it returns true.
 *
 * @since 3.3.0
 *
 * @param string $type The type of analysis setting to retrieve ('core', 'plugins', 'themes', 'php', 'apache', 'nginx').
 *
 * @return bool False if the specified type is set, true if not set or invalid.
 */
function wpvulnerability_analyze_filter( $type ) {

	// Retrieve the analysis settings based on the WordPress setup.
	if ( ! is_multisite() ) {
		$wpvulnerability_analyze = get_option( 'wpvulnerability-analyze', array() );
	} elseif ( is_multisite() ) {
		$wpvulnerability_analyze = get_site_option( 'wpvulnerability-analyze', array() );
	}

	// Check the specified type and return the appropriate value.
	switch ( $type ) {
		case 'core':
			if ( isset( $wpvulnerability_analyze['core'] ) && (int) $wpvulnerability_analyze['core'] ) {
				return false;
			} else {
				return true;
			}
		case 'plugins':
			if ( isset( $wpvulnerability_analyze['plugins'] ) && (int) $wpvulnerability_analyze['plugins'] ) {
				return false;
			} else {
				return true;
			}
		case 'themes':
			if ( isset( $wpvulnerability_analyze['themes'] ) && (int) $wpvulnerability_analyze['themes'] ) {
				return false;
			} else {
				return true;
			}
		case 'php':
			if ( isset( $wpvulnerability_analyze['php'] ) && (int) $wpvulnerability_analyze['php'] ) {
				return false;
			} else {
				return true;
			}
		case 'apache':
			if ( isset( $wpvulnerability_analyze['apache'] ) && (int) $wpvulnerability_analyze['apache'] ) {
				return false;
			} else {
				return true;
			}
		case 'nginx':
			if ( isset( $wpvulnerability_analyze['nginx'] ) && (int) $wpvulnerability_analyze['nginx'] ) {
				return false;
			} else {
				return true;
			}
		default:
			return true;
	}
}

/**
 * Clean the cache after an update
 *
 * @since 2.0.0
 *
 * @return void
 */
add_action( 'upgrader_process_complete', 'wpvulnerability_update_database_data', 10, 2 );
