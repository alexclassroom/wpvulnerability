<?php
/**
 * Primary class file for the Health Check plugin.
 *
 * @package Health Check
 */

// Make sure the file is not directly accessible.
if ( ! defined( 'ABSPATH' ) ) {
	die( 'We\'re sorry, but you can not directly access this file.' );
}

/**
 * Class HealthCheck
 */
class Health_Check_Vulnerability {

	/**
	 * Notices to show at the head of the admin screen.
	 *
	 * @access public
	 *
	 * @var array
	 */
	public $admin_notices = array();

	/**
	 * HealthCheck constructor.
	 *
	 * @uses Health_Vulnerability::init()
	 *
	 * @return void
	 */
	public function __construct() {
		add_action( 'admin_enqueue_scripts', array( $this, 'enqueues' ) );

		add_action( 'admin_head', array( $this, 'admin_head' ) );

		register_activation_hook( WPVULNERABILITY_PLUGIN_FILE, array( $this, 'on_activation' ) );
		add_action( 'vpc_pull_db_data_event', array( $this, 'get_installed_plugins' ) );

		register_deactivation_hook( WPVULNERABILITY_PLUGIN_FILE, array( $this, 'on_deactivation' ) );
		add_filter( 'plugin_action_links_' . plugin_basename( WPVULNERABILITY_PLUGIN_FILE ), array( $this, 'add_settings_link' ) );

		add_action( 'activated_plugin', array( $this, 'get_installed_plugins' ), 10, 2 );
		add_action( 'upgrader_process_complete', array( $this, 'get_installed_plugins' ), 10, 2 );
	}

	/**
	 * Enqueue assets.
	 *
	 * Conditionally enqueue our CSS and JavaScript when viewing plugin related pages in wp-admin.
	 *
	 * @uses wp_enqueue_style()
	 * @uses plugins_url()
	 * @uses wp_enqueue_script()
	 * @uses wp_localize_script()
	 * @uses esc_html__()
	 *
	 * @return void
	 */
	public function enqueues() {
		$screen = get_current_screen();

		wp_enqueue_style(
			'wpvulnerability',
			trailingslashit( WPVULNERABILITY_PLUGIN_URL ) . 'assets/admin.css',
			array(),
			WPVULNERABILITY_PLUGIN_VERSION
		);
	}

	/**
	 * Admin Head
	 * gets installed plugins cache, adds after row text and notices based on the results for the plugin page
	 * @return null
	 */
	public function admin_head() {
		global $pagenow;

		$plugins = $this->get_installed_plugins_cache();

		// add after plugin row text
		foreach ( $plugins as $plugin ) {
			$path         = $plugin['file_path'];
			$added_notice = false;

			if ( isset( $plugin['vulnerable'] ) && 'true' == $plugin['vulnerable'] ) {
				add_action( 'after_plugin_row_' . $path, array( $this, 'after_row_text' ), 10, 3 );

				if ( ! $added_notice ) {
					add_action( 'admin_notices', array( $this, 'vulnerable_admin_notice' ) );
					$added_notice = true;
				}
			}
		}
	}

	/**
	 * Get Installed Plugins Cache
	 * gets the installed plugins, checks for vulnerabilities with cached results
	 * @return array installed plugins with vulnerability data
	 */

	/**
	 * Get Installed plugins cache
	 *
	 * @return array
	 */
	public function get_installed_plugins_cache() {

		$plugin_data = json_decode( get_option( 'wpvulnerability-data' ) );
		if ( ! empty( $plugin_data ) ) {

			if ( ! function_exists( 'get_plugins' ) ) {
					require_once ABSPATH . 'wp-admin/includes/plugin.php';
			}

			$plugins = json_decode( get_option( 'wpvulnerability-data' ), true );

			foreach ( $plugins as $key => $plugin ) {
				$plugin          = $this->get_cached_plugin_vulnerabilities( $plugin, $key );
				$plugins[ $key ] = $plugin;
			}
			return $plugins;
		} else {
			// this occurs only right after activation
			$this->get_installed_plugins();
		}
	}

	/**
	 * On Activation
	 * callback function for when the plugin is activated
	 * add plugin data option if it isn't created already, schedule wp-cron job
	 */
	public function on_activation() {

		if ( ! get_option( 'wpvulnerability-data' ) ) {
			add_option( 'wpvulnerability-data', '' );
		}

		if ( ! get_option( 'wpvulnerability_allow_emails' ) ) {
			add_option( 'wpvulnerability_allow_emails', 1 );
		}

		wp_schedule_event( time(), 'twicedaily', 'wpvulnerability_pull_db_data_event' );

		$this->get_installed_plugins( false );
	}

	/**
	 * On Deactivation
	 * callback function when a plugin is deactivated
	 * delete, option and remove wp-cron job
	 */
	public function on_deactivation() {
		delete_option( 'wpvulnerability-data' );
		wp_clear_scheduled_hook( 'wpvulnerability_pull_db_data_event' );
	}
	/**
	 * Get Cached Plugin Vulnerabilities
	 * pulls installed plugins, compares version to cached vulnerabilities, adds vulnerable key to plugin.
	 * @param  array  $plugin    
	 * @param  string $file_path plugin file path
	 * @return array             updated plugin array
	 */
	public function get_cached_plugin_vulnerabilities( $plugin, $file_path ) {

		global $installed_plugins;

		// TODO: convert to cached installed plugins
		if ( ! is_array( $installed_plugins ) ) {

			if ( ! function_exists( 'get_plugins' ) ) {
					require_once ABSPATH . 'wp-admin/includes/plugin.php';
				}

			$installed_plugins = get_plugins();
		}

		$plugin = $this->set_text_domain( $plugin );

		if ( isset( $installed_plugins[ $file_path ]['Version'] ) ) {
			// updated the cached version with the one taken from the currently installed
			$plugin['Version']             = $installed_plugins[ $file_path ]['Version'];
			$plugin['vulnerable'] = 'false';

			if ( ! empty( $plugin['vulnerabilities'] ) ) {
				$plugin['vulnerable'] = 'true';
			}

		}
		$plugin['file_path'] = $file_path;
		return $plugin;
	}

	/**
	 * Get Fresh Plugin Vulnerabilities
	 * pull vulnerabilities through API, compare version to vulnerabilities, add is_know_vulnerable key
	 * @param  array  $plugin_data
	 * @param  string $file_path plugin file path
	 * @return array             updated plugin
	 */
	public function get_fresh_plugin_vulnerabilities( $plugin_data, $file_path ) {
		$plugin_data               = $this->set_text_domain( $plugin_data );
		$plugin_slug               = $plugin_data['TextDomain'];
		$plugin_data['vulnerable'] = 'false';
		$plugin_data['file_path']  = $file_path;

		$plugin_vuls = wpvulnerability_get_plugin( $plugin_slug, $plugin_data['Version'] );
		if ( ! empty( $plugin_vuls ) ) {
			$plugin_data['vulnerabilities'] = $plugin_vuls;
			$plugin_data['vulnerable']      = 'true';
		}

		return $plugin_data;
	}

	/**
	 * Set Text Domain
	 * sets the text domain to the TextDomain key if it is not set
	 * @param  array $plugin
	 * @return array          updated plugin
	 */
	public function set_text_domain( $plugin ) {

		// get text domain from folder if it isn't listed
		if ( empty( $plugin['TextDomain'] ) && isset( $plugin['file_path'] ) ) {
			$folder_name = explode( '/', $plugin['file_path'] );
			$plugin['TextDomain'] = $folder_name[0];
		}

		return $plugin;

	}

	/**
	 * Get Installed Plugins
	 * gets the installed plugins, checks for vulnerabilities in them, caches the data, sends email if vulnerabilities detected
	 *
	 * @return array
	 */
	public function get_installed_plugins() {

		if ( ! function_exists( 'get_plugins' ) ) {
			require_once ABSPATH . 'wp-admin/includes/plugin.php';
		}

		$plugins      = get_plugins();
		$vuln_plugins = array();
		foreach ( $plugins as $key => $plugin ) {
			$plugin          = $this->get_fresh_plugin_vulnerabilities( $plugin, $key );
			$plugins[ $key ] = $plugin;

			if ( isset( $plugin['vulnerable'] ) && 'true' == $plugin['vulnerable'] ) {
				$name           = $plugin['Name'];
				$vuln_plugins[] = $plugin['Name'];
			}
		}

		update_option( 'wpvulnerability-data', json_encode( $plugins ) );

		return $plugins;
	}

	/**
	 * Add Settings Link
	 * @param array $links links that appear in the plugin row
	 */
	public function add_settings_link( $links ) {
		$links[] = '<a href="' . get_admin_url( null, 'options-general.php?page=vpc-settings' ) . '">Settings</a>';
		return $links;
	}

	/**
	 * After Row Text
	 * callback function for adding vulnerability notice under vulnerable plugins
	 * @param  string $plugin_file main plugin folder/file_name
	 * @param  array  $plugin_data
	 */
	public function after_row_text( $plugin_file, $plugin_data, $status ) {

		global $wpvulnerability_data;

		if ( ! is_array( $wpvulnerability_data ) ) {
			$wpvulnerability_data = json_decode( get_option( 'wpvulnerability-data' ), true );
		}

		$message = sprintf(
			/* translators: 1: plugin name */
			__( '%1$s has a known vulnerability that may be affecting this version. Please update this plugin.', 'vulnerable-plugin-checker' ),
			$plugin_data['Name']
		);

		$string  = '<tr class="active update" style="">';
		$string .= '<td style="border-left: 4px solid #d54e21; border-bottom: 1px solid #E2E2E2;background-color:#FAEDE8;">&nbsp;</td>';
		$string .= '<td colspan="3" style="border-bottom: 1px solid #E2E2E2; color: #D54E21;background-color:#FAEDE8;">'; 
		$string .= '<p style="color: #D54E21"><strong>' . $message . '</strong>';
		$string .= '</p>';
		$string .= '<table>';

		$vulnerabilities = $this->get_cached_plugin_vulnerabilities( $wpvulnerability_data[ $plugin_file ], $plugin_file );
		foreach ( $vulnerabilities['vulnerabilities'] as $vulnerability ) {
			$string .= '<tr>';
			$string .= '<td style="background-color:#FAEDE8;padding: 4px 15px 4px 0;"><strong>' . esc_html( $vulnerability['name'] ) . '</strong></td>';
			$string .= '</tr>';
		}
		$string .= '</table>';
		$string .= '</td>';
		$string .= '</tr>';

		echo $string;
	}

	/**
	 * Vulnerable Admin Notice
	 * prints out error message if plugin(s) is/are vulnerable
	 */
	public function vulnerable_admin_notice() {
		$class   = 'notice notice-error is-dismissible';
		$message = __( '<strong>WPVulnerability:</strong> One or more plugins currently installed have known vulnerabilities with their current version. I suggest updating each vulnerable plugin if an update is available', 'vulnerable-plugin-checker' );

		printf(
			'<div class="%1$s"><p>%2$s</p></div>',
			esc_html( $class ),
			esc_html( $message )
		);
	}
}
